// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {PanopticPoolTest} from "./PanopticPool.t.sol";
import {CallbackLib} from "@libraries/CallbackLib.sol";
import {IUniswapV3Pool} from "v3-core/interfaces/IUniswapV3Pool.sol";
import {IERC20Partial} from "@tokens/interfaces/IERC20Partial.sol";

// Mock Pool that supports swap and calls callback
contract UniPoolSwapMock {
     address public token0;
    address public token1;
    uint24 public fee;
    int24 public tickSpacing;

    constructor(address _token0, address _token1, uint24 _fee, int24 _tickSpacing) {
        token0 = _token0;
        token1 = _token1;
        fee = _fee;
        tickSpacing = _tickSpacing;
    }
    
    // Minimal slot0
    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool) {
        return (0, 0, 0, 0, 0, 0, true);
    }
    
    function feeGrowthGlobal0X128() external view returns (uint256) { return 0; }
    function feeGrowthGlobal1X128() external view returns (uint256) { return 0; }

    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1) {
        // Simulate Swap
        // For simplicity: 1:1 exchange rate.
        
        if (zeroForOne) {
            // Sell Token0, Buy Token1
            // AmountSpecified > 0: Exact Input (Token0)
            // AmountSpecified < 0: Exact Output (Token1)
            
            if (amountSpecified > 0) {
                 amount0 = amountSpecified;
                 amount1 = -amountSpecified;
            } else {
                 amount1 = amountSpecified;
                 amount0 = -amountSpecified;
            }
        } else {
            // Sell Token1, Buy Token0
             if (amountSpecified > 0) {
                 amount0 = -amountSpecified;
                 amount1 = amountSpecified;
            } else {
                 amount0 = amountSpecified;
                 amount1 = -amountSpecified;
            }
        }

        // CALL CALLBACK
        // SFPM expects IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0Delta, amount1Delta, data)
        // Note: msg.sender here (in callback) will be THIS POOL.
        
        // We cast SFPM address (which is likely reachable via data or implicit assumption)
        // Wait, the POOL doesn't know SFPM address blindly.
        // But `SFPM` is the one implementing `uniswapV3SwapCallback`.
        // The prompt is: "The caller of this method receives a callback".
        // Caller is `msg.sender` (Bob).
        // Bob is NOT SFPM.
        // **Ah.** If Bob calls `swap`, `swap` calls `Bob.callback`.
        // Bob is `SFPMSwapExploitTest` contract (via prank).
        // Bob needs to forward the callback to `SFPM`??
        // NO. `SFPM.uniswapV3SwapCallback` validates `msg.sender` is POOL.
        // If Bob forwards, `msg.sender` in SFPM is Bob (FAIL).
        
        // **So Bob cannot use SFPM callback.**
        // Bob needs `Pool` to call `SFPM.callback`.
        // But `Pool` is hardcoded to call `msg.sender`.
        // **Logic Check**: `UniswapV3Pool.sol`:
        // `IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(...)`
        // So the Call ALWAYS goes to the `swap` caller.
        
        // **This means SFPM MUST be the caller of `swap`.**
        // **My Exploit Theory is INVALID** for `swap`.
        
        // Is it valid for `mint`?
        // `mint(recipient, ..., data)`.
        // "call IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback"
        // Also calls `msg.sender`.
        
        // **Flash**?
        // `flash(recipient, ..., data)`.
        // "call IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback"
        
        // **Conclusion**: All Uniswap V3 callbacks go to `msg.sender`.
        // Therefore, `SFPM` is only vulnerable if `SFPM` calls `swap/mint/flash`.
        // And `SFPM` only does that in `swapInAMM`, `_mintLiquidity`, etc.
        // And those are internally controlled.
        
        // **Is there any way to make SFPM call `swap` with user data?**
        // No.
        
        // **Wait! `multicall`?**
        // If `SFPM` inherits `Multicall`, it allows batching calls *to itself*.
        // It does NOT allow calling arbitrary external contracts (like `Pool.swap`).
        
        // **So the vulnerability is likely NON-EXISTENT** due to Uniswap architecture.
        // `SFPM` code assumes `msg.sender` checks are enough because *only SFPM* can trigger the callback *to SFPM*.
        // Since `Pool` calls `msg.sender`, and `msg.sender` must be `SFPM`.
        
        // **Unless... SFPM allows `flash`?**
        // SFPM does NOT verify `msg.sender` in `uniswapV3SwapCallback`?
        // It DOES verify `msg.sender` is Pool.
        // It verify `msg.sender` matches Factory.
        
        // OK, I'll stop this PoC. The vector is closed by Uniswap design.
    }
}
