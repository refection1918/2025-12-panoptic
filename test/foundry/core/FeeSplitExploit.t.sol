// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {CollateralTrackerTest} from "./CollateralTracker.t.sol";
import {TokenId, TokenIdLibrary} from "@types/TokenId.sol";
import "forge-std/Test.sol";
import {IERC20Partial} from "@tokens/interfaces/IERC20Partial.sol";
import {Constants} from "@libraries/Constants.sol";

contract FeeSplitExploitTest is CollateralTrackerTest {
    // using TokenIdLibrary for TokenId; // Redundant/Error if not imported, and global using should suffice

    function test_FeeDiscountExploit_Comparison() public {
        _initWorld(0);
        
        // Grant tokens to Alice and set her up
        _grantTokens(Alice);
        vm.startPrank(Alice);
        IERC20Partial(token0).approve(address(collateralToken0), type(uint256).max);
        IERC20Partial(token1).approve(address(collateralToken1), type(uint256).max);
        collateralToken0.deposit(10_000 ether, Alice);
        collateralToken1.deposit(10_000 ether, Alice);
        vm.stopPrank();

        // Setup Bob just like Alice
        address Bob = makeAddr("Bob");
        _grantTokens(Bob);
        
        vm.startPrank(Bob);
        IERC20Partial(token0).approve(address(collateralToken0), type(uint256).max);
        IERC20Partial(token1).approve(address(collateralToken1), type(uint256).max);
        collateralToken0.deposit(10_000 ether, Bob);
        collateralToken1.deposit(10_000 ether, Bob);
        vm.stopPrank();
        
        // Prepare TokenId (using currentTick which is set by _initWorld)
        tokenId = TokenId.wrap(0).addPoolId(poolId).addLeg(
            0, 1, 0, 0, 0, 0, currentTick, 10
        );
        positionIdList.push(tokenId);
        uint128 positionSize = 10 ether;

        // Alice mints NO builder
        vm.startPrank(Alice);
        uint256 balAliceBefore = collateralToken0.balanceOf(Alice);
        mintOptions(panopticPool, positionIdList, positionSize, 0, Constants.MAX_POOL_TICK, Constants.MIN_POOL_TICK, true);
        uint256 balAliceAfter = collateralToken0.balanceOf(Alice);
        uint256 costAlice = balAliceBefore - balAliceAfter;
        vm.stopPrank();
        
        // Bob mints WITH builder code
        vm.startPrank(Bob);
        uint256 balBobBefore = collateralToken0.balanceOf(Bob);
        
        uint256 builderCode = 12345;
        
        mintOptions(
            panopticPool,
            positionIdList,
            positionSize,
            0,
            Constants.MAX_POOL_TICK,
            Constants.MIN_POOL_TICK,
            true,
            builderCode
        );
        
        uint256 balBobAfter = collateralToken0.balanceOf(Bob);
        uint256 costBob = balBobBefore - balBobAfter;
        vm.stopPrank();
        
        console2.log("Cost Alice (No Builder): ", costAlice);
        console2.log("Cost Bob   (With Builder): ", costBob);
        
        assertLt(costBob, costAlice, "User with builder code should pay less than user without");
        
        // Expected cost is 90% (6500 + 2500 bps = 9000 bps = 0.9)
        uint256 expectedCostBob = (costAlice * 90) / 100;
        assertApproxEqAbs(costBob, expectedCostBob, 10, "Cost should be exactly 90% of full commission");
    }
}
